logMessage(sprintf('Starting the external script: %s.m \n\n', mfilename) ...
    ,logFilePath,true);


%% Preallocation
if ~exist('nearestNeighbourCases','var')
    logMessage(sprintf(['With this script the angle dependency of solid \n' ...
        'lipid is simulated. The dataset is rotated to a random theta\n ' ...
        '[0,pi] and random phi [0,2pi] to get R1 averaged over different\n ' ...
        'angles. \n\n']),logFilePath,false);
    logMessage('Preallocation of arrays as a first part of the script' ...
        ,logFilePath,true);
    nearestNeighbourCases = getNearestNeighbourCases(configuration ...
        ,numberOfHs,logFilePath);
    nearestNeighbourCasesCount = size(nearestNeighbourCases,2);
    nearestNeighbours = max(nearestNeighbourCases);
    
    averagingRegionForSpecDens = getAveragingRegionForSpecDens( ...
        configuration.averagingRegionForSpectralDensity,logFilePath);
    
    atomCounter = configuration.atomCounter;
    calculatedAtomIndices = zeros(1,atomsToCalculate);
    
    randomSequenceOfAtoms = randperm(numberOfHs);
    logMessage(sprintf('%s:%s', 'Random sequence of atoms: ' ...
        ,sprintf(' %i',randomSequenceOfAtoms(1:15))),logFilePath,false);
    randomSequenceOfThetas = rand(1,length(randomSequenceOfAtoms))*pi;
    randomSequenceOfPhis = rand(1,length(randomSequenceOfAtoms))*2*pi;
    
    nearestNeighboursIDs = zeros(1,max(nearestNeighbourCases));
    nearestNeighbourDistancesPow3 = zeros(max(nearestNeighbourCases) ...
        ,timeSteps,'single');
    
    rotatedX = zeros(max(nearestNeighbourCases),timeSteps,'single');
    rotatedY = zeros(max(nearestNeighbourCases),timeSteps,'single');
    rotatedZ = zeros(max(nearestNeighbourCases),timeSteps,'single');
    
    polarAngle = zeros(max(nearestNeighbourCases),timeSteps,'single');
    azimuthAngle = zeros(max(nearestNeighbourCases),timeSteps,'single');
    
    sphericalHarmonicZerothOrder = zeros(max(nearestNeighbourCases) ...
        ,timeSteps,'like',double(1j));
    sphericalHarmonicFirstOrder = zeros(max(nearestNeighbourCases) ...
        ,timeSteps,'like',double(1j));
    sphericalHarmonicSecondOrder = zeros(max(nearestNeighbourCases) ...
        ,timeSteps,'like',double(1j));
    
    for nearestNeighboursCase = nearestNeighbourCases
        key = sprintf('nearestNeighbours%g',nearestNeighboursCase);
        
        r1Estimation_NN.(key) = zeros(1);
        
        correlationFunctionZerothOrder.(key) = zeros(1,timeSteps ...
            ,'like',double(1j));
        correlationFunctionFirstOrder.(key) = zeros(1,timeSteps ...
            ,'like',double(1j));
        correlationFunctionSecondOrder.(key) = zeros(1,timeSteps ...
            ,'like',double(1j));
        
        sumCorrFuncZerothOrder.(key) = zeros(1,timeSteps,'like' ...
            ,double(1j));
        sumCorrFuncFirstOrder.(key) = zeros(1,timeSteps,'like' ...
            ,double(1j));
        sumCorrFuncSecondOrder.(key) = zeros(1,timeSteps,'like' ...
            ,double(1j));
    end
    logMessage('Arrays successfully preallocated',logFilePath,false);
    return;
end
meanPositions = single([mean(trajectoryX,2) mean(trajectoryY,2) ...
        mean(trajectoryZ,2)]);
atomTimer = zeros(1,atomsToCalculate);

%% Start simulation

printBreakLineToLogFile(logFilePath);
zAxis = [0 0 1];
yAxis = [0 1 0];

logMessage('Start simulation.',logFilePath,true);
for atomNumber = randomSequenceOfAtoms(atomCounter:atomsToCalculate)
    atomTimerStart = tic;
    
    theta = randomSequenceOfThetas(atomNumber);
    phi = randomSequenceOfPhis(atomNumber);
    calculatedAtomIndices(atomCounter) = atomNumber; %#ok<SAGROW>
    logMessage(sprintf(['Selected atom number %i and theta = %.4f' ...
        ' and phi = %.4f'],atomNumber,theta,phi),logFilePath ...
        ,false);
    
    [trajectoryX,trajectoryY,trajectoryZ] = calculateRelativePositions( ...
        trajectoryX,trajectoryY,trajectoryZ,atomNumber);
    
    [nearestNeighboursIDs,nearestNeighbourDistancesPow3] =  ...
        findNearestNeighboursIDs(nearestNeighbours,trajectoryX ...
        ,trajectoryY,trajectoryZ);
    
    rotationMatrixPhi = get3DRotationMatrix(phi,zAxis);
    rotationMatrixTheta = get3DRotationMatrix(theta,yAxis);
    totalRotationMatrix = ...
        rotationMatrixTheta*rotationMatrixPhi;
    [rotatedX,rotatedY,rotatedZ]  ...
        = rotateTrajectoriesWithRotationMatrix( ...
        totalRotationMatrix,trajectoryX(nearestNeighboursIDs,:) ...
        ,trajectoryY(nearestNeighboursIDs,:) ...
        ,trajectoryZ(nearestNeighboursIDs,:));
    
    [polarAngle,azimuthAngle] = ...
        transformToSphericalCoordinates(rotatedX,rotatedY,rotatedZ);
                
    [sphericalHarmonicZerothOrder,sphericalHarmonicFirstOrder ...
        ,sphericalHarmonicSecondOrder] = calculateSphericalHarmonics( ...
        polarAngle,azimuthAngle,nearestNeighbourDistancesPow3);
    
    correlationFunctionZerothOrder = ...
        calculateCorrelationFunctionForDifferentNNCases( ...
        sphericalHarmonicZerothOrder,nearestNeighbourCases);
    sumCorrFuncZerothOrder = ...
        addTwoCorrelationFunctionStructsWithoutAngleDependency( ...
        sumCorrFuncZerothOrder,correlationFunctionZerothOrder);
    correlationFunctionFirstOrder = ...
        calculateCorrelationFunctionForDifferentNNCases( ...
        sphericalHarmonicFirstOrder,nearestNeighbourCases);
    sumCorrFuncFirstOrder = ...
        addTwoCorrelationFunctionStructsWithoutAngleDependency( ...
        sumCorrFuncFirstOrder,correlationFunctionFirstOrder);
    correlationFunctionSecondOrder = ...
        calculateCorrelationFunctionForDifferentNNCases( ...
        sphericalHarmonicSecondOrder,nearestNeighbourCases);
    sumCorrFuncSecondOrder = ...
        addTwoCorrelationFunctionStructsWithoutAngleDependency( ...
        sumCorrFuncSecondOrder,correlationFunctionSecondOrder);
    
    for fieldName = string(fieldnames(sumCorrFuncFirstOrder))'
        [averageSpectralDensityFirstOrder ...
            ,averageSpectralDensitySecondOrder] ...
            = calculateSpectralDensities( ...
            sumCorrFuncFirstOrder.(fieldName)/atomCounter ...
            ,sumCorrFuncSecondOrder.(fieldName)/atomCounter,omega0 ...
            ,deltaTInS,averagingRegionForSpecDens);
        
        r1Estimation_NN.(fieldName) = calculateR1WithSpectralDensity( ...
            averageSpectralDensityFirstOrder ...
            ,averageSpectralDensitySecondOrder,dipolDipolConstant);
        
        logMessage(sprintf(['=> %s\n' ...
            '    Estimated relaxation rate for calculated atoms:' ...
            ' %.4f\n'],fieldName,r1Estimation_NN.(fieldName)) ...
            ,logFilePath,false);
    end
    
    printDottedBreakLineToLogFile(logFilePath);
    if mod(atomCounter,configuration.savingIntervall) == 0
        lastSavingDate = datestr(now,'yyyymmdd_HHMM');
        createDataSavingObject();
        save(resultsFileSavingPath,'-struct','dataSavingObject','-v7.3');
        logMessage('Saved data',logFilePath);
    end
    logMessage(sprintf('Calculated %i atom(s)',atomCounter),logFilePath ...
        ,false);
    atomTimer(atomCounter) = toc(atomTimerStart);
    averageTimeForOneAtom = seconds(mean(atomTimer(1:atomCounter)));
    logMessage(sprintf([' ---> Average time for one atom: %s \n' ...
       '        Approximately ready on: %s.'] ...
        ,datestr(averageTimeForOneAtom,'HH:MM:SS') ...
        ,datetime('now')+averageTimeForOneAtom ...
        *(atomsToCalculate-atomCounter)),logFilePath,false);
    printEqualSignBreakLineToLogFile(logFilePath);
    atomCounter = atomCounter + 1;
end

