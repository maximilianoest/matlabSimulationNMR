logMessage(sprintf('Starting the external script: %s.m \n\n', mfilename) ...
    ,logFilePath,true);


%% Preallocation
if ~exist('nearestNeighbours','var')
    logMessage(sprintf(['With this script the angle dependency of solid \n' ...
        'lipid is simulated. The dataset is rotated to a random theta\n ' ...
        '[0,pi] and random phi [0,2pi] to get R1 averaged over different\n ' ...
        'angles. The correlation functions are saved with location \n' ...
        'dependency. \n\n']),logFilePath,false);
    logMessage('Preallocation of arrays as a first part of the script' ...
        ,logFilePath,true);
    nearestNeighbours = configuration.nearestNeighbours;
    locationsCount = configuration.locationsCount;
    
    averagingRegionForSpecDens = getAveragingRegionForSpecDens( ...
        configuration.averagingRegionForSpectralDensity,logFilePath);
    
    atomCounter = configuration.atomCounter;
    calculatedAtomIndices = zeros(1,atomsToCalculate);
    
    randomSequenceOfAtoms = randperm(numberOfHs);
    logMessage(sprintf('%s:%s', 'Random sequence of atoms: ' ...
        ,sprintf(' %i',randomSequenceOfAtoms(1:15))),logFilePath,false);
    randomSequenceOfThetas = rand(1,length(randomSequenceOfAtoms))*pi;
    randomSequenceOfPhis = rand(1,length(randomSequenceOfAtoms))*2*pi;
    
    nearestNeighboursIDs = zeros(1,nearestNeighbours);
    nearestNeighbourDistancesPow3 = zeros(nearestNeighbours,timeSteps ...
        ,'single');
    
    rotatedX = zeros(nearestNeighbours,timeSteps,'single');
    rotatedY = zeros(nearestNeighbours,timeSteps,'single');
    rotatedZ = zeros(nearestNeighbours,timeSteps,'single');
    
    polarAngle = zeros(nearestNeighbours,timeSteps,'single');
    azimuthAngle = zeros(nearestNeighbours,timeSteps,'single');
    
    sphericalHarmonicZerothOrder = zeros(nearestNeighbours,timeSteps ...
        ,'like',double(1j));
    sphericalHarmonicFirstOrder = zeros(nearestNeighbours,timeSteps ...
        ,'like',double(1j));
    sphericalHarmonicSecondOrder = zeros(nearestNeighbours,timeSteps ...
        ,'like',double(1j));
    
    r1Estimation = zeros(1,numberOfHs);
    
    correlationFunctionZerothOrder = zeros(1,timeSteps,'like',double(1j));
    correlationFunctionFirstOrder = zeros(1,timeSteps,'like',double(1j));
    correlationFunctionSecondOrder = zeros(1,timeSteps,'like',double(1j));
    
    sumCorrFuncZerothOrderLocDep = zeros(locationsCount,timeSteps,'like' ...
        ,double(1j));
    sumCorrFuncFirstOrderLocDep = zeros(locationsCount,timeSteps,'like' ...
        ,double(1j));
    sumCorrFuncSecondOrderLocDep = zeros(locationsCount,timeSteps,'like' ...
        ,double(1j));
    
    sumCorrFuncZerothOrder = zeros(1,timeSteps,'like',double(1j));
    sumCorrFuncFirstOrder = zeros(1,timeSteps,'like',double(1j));
    sumCorrFuncSecondOrder = zeros(1,timeSteps,'like',double(1j));

    logMessage('Arrays successfully preallocated',logFilePath,false);
    return;
end
meanPositions = single([mean(trajectoryX,2) mean(trajectoryY,2) ...
        mean(trajectoryZ,2)]);
atomTimer = zeros(1,atomsToCalculate);
%% location dependency trail and error
minX = min(meanPositions(:,1)) - 0.00001;
maxX = max(meanPositions(:,1)) + 0.00001;
locationsForLocationDep = linspace(minX,maxX,locationsCount+1);
atomCounterForLocationDep = zeros(1,length(locationsForLocationDep));

%% Start simulation
zAxis = [0 0 1];
yAxis = [0 1 0];

logMessage('Start simulation.',logFilePath,true);
for atomNumber = randomSequenceOfAtoms(atomCounter:atomsToCalculate)
    atomTimerStart = tic;
    
    theta = randomSequenceOfThetas(atomNumber);
    phi = randomSequenceOfPhis(atomNumber);
    calculatedAtomIndices(atomCounter) = atomNumber; %#ok<SAGROW>
    logMessage(sprintf(['Selected atom number %i and theta = %.4f' ...
        ' and phi = %.4f'],atomNumber,theta,phi),logFilePath ...
        ,false);
    xPos = meanPositions(atomNumber,1);
    for locationNr = 1:locationsCount - 1
        locationLowerBound = locationsForLocationDep(locationNr);
        locationUpperBound = locationsForLocationDep(locationNr + 1);
        
        if xPos > locationLowerBound && xPos < locationUpperBound
            locationArrayIndex = locationNr;
            break;
        end
    end
    
    atomCounterForLocationDep(locationArrayIndex) ...
        = atomCounterForLocationDep(locationArrayIndex) + 1;
    xPosMatrix(locationArrayIndex ...
        ,atomCounterForLocationDep(locationArrayIndex)) = xPos; %#ok<SAGROW>
    
    [trajectoryX,trajectoryY,trajectoryZ] = calculateRelativePositions( ...
        trajectoryX,trajectoryY,trajectoryZ,atomNumber);
    
    [nearestNeighboursIDs,nearestNeighbourDistancesPow3] =  ...
        findNearestNeighboursIDs(nearestNeighbours,trajectoryX ...
        ,trajectoryY,trajectoryZ);
    
    rotationMatrixPhi = get3DRotationMatrix(phi,zAxis);
    rotationMatrixTheta = get3DRotationMatrix(theta,yAxis);
    totalRotationMatrix = ...
        rotationMatrixTheta*rotationMatrixPhi;
    [rotatedX,rotatedY,rotatedZ]  ...
        = rotateTrajectoriesWithRotationMatrix( ...
        totalRotationMatrix,trajectoryX(nearestNeighboursIDs,:) ...
        ,trajectoryY(nearestNeighboursIDs,:) ...
        ,trajectoryZ(nearestNeighboursIDs,:));
    
    [polarAngle,azimuthAngle] = ...
        transformToSphericalCoordinates(rotatedX,rotatedY,rotatedZ);
                
    [sphericalHarmonicZerothOrder,sphericalHarmonicFirstOrder ...
        ,sphericalHarmonicSecondOrder] = calculateSphericalHarmonics( ...
        polarAngle,azimuthAngle,nearestNeighbourDistancesPow3);
    
    correlationFunctionZerothOrder = ...
        calculateCorrelationFunction(sphericalHarmonicZerothOrder);
    sumCorrFuncZerothOrderLocDep(locationArrayIndex,:) = ...
        sumCorrFuncZerothOrderLocDep(locationArrayIndex,:) ...
        + correlationFunctionZerothOrder; %#ok<SAGROW>
    sumCorrFuncZerothOrder = sumCorrFuncZerothOrder ...
        + correlationFunctionZerothOrder;
    
    correlationFunctionFirstOrder = ...
        calculateCorrelationFunction(sphericalHarmonicFirstOrder);
    sumCorrFuncFirstOrderLocDep(locationArrayIndex,:) = ...
        sumCorrFuncFirstOrderLocDep(locationArrayIndex) ...
        + correlationFunctionFirstOrder; %#ok<SAGROW>
    sumCorrFuncFirstOrder = sumCorrFuncFirstOrder ...
        + correlationFunctionFirstOrder;
    
    correlationFunctionSecondOrder = ...
        calculateCorrelationFunction(sphericalHarmonicSecondOrder);
    sumCorrFuncSecondOrderLocDep(locationArrayIndex,:) = ...
        sumCorrFuncSecondOrderLocDep(locationArrayIndex,:) ...
        + correlationFunctionSecondOrder; %#ok<SAGROW>
    sumCorrFuncSecondOrder = sumCorrFuncSecondOrder ...
        + correlationFunctionSecondOrder;
    
    [averageSpectralDensityFirstOrder,averageSpectralDensitySecondOrder] ...
        = calculateSpectralDensities( ...
        sumCorrFuncFirstOrder/atomCounter ...
        ,sumCorrFuncSecondOrder/atomCounter,omega0,deltaTInS ...
        ,averagingRegionForSpecDens);
    r1Estimation(atomCounter) = calculateR1WithSpectralDensity( ...
        averageSpectralDensityFirstOrder ...
        ,averageSpectralDensitySecondOrder,dipolDipolConstant); %#ok<SAGROW>
    
    logMessage(sprintf( ...
        ' => Estimated relaxation rate for calculated atoms: %.4f' ...
        ,r1Estimation(atomCounter)),logFilePath,false);
    
    if mod(atomCounter,configuration.savingIntervall) == 0
        lastSavingDate = datestr(now,'yyyymmdd_HHMM');
        createDataSavingObject();
        save(resultsFileSavingPath,'-struct','dataSavingObject','-v7.3');
        logMessage('Saved data',logFilePath);
    end
    logMessage(sprintf('Calculated %i atom(s)',atomCounter),logFilePath ...
        ,false);
    atomTimer(atomCounter) = toc(atomTimerStart);
    averageTimeForOneAtom = seconds(mean(atomTimer(1:atomCounter)));
    logMessage(sprintf([' ---> Average time for one atom: %s \n' ...
       '        Approximately ready on: %s.'] ...
        ,datestr(averageTimeForOneAtom,'HH:MM:SS') ...
        ,datetime('now')+averageTimeForOneAtom ...
        *(atomsToCalculate-atomCounter)),logFilePath,false);
    printEqualSignBreakLineToLogFile(logFilePath);
    atomCounter = atomCounter + 1;
end

