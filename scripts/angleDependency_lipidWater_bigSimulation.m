%% script start
logMessage(sprintf('Starting the external script: %s.m \n\n', mfilename) ...
    ,logFilePath,true);

logMessage(sprintf(['With this script the "angle dependency" of the lipid ' ...
    'waters is simulated. Because the angle dependency of water is \n' ...
    'small compared to the influence of the solid lipid part, the ' ...
    'angle dependency is neglected. Thus the dataset is rotated only \n' ...
    'once. Futhermore, a duration of 25ns and da deltaT of 0.2ps is ' ...
    'chosen because this was the configuration which seems to be the \n' ...
    'best for this simulation (see interim results). Additionally, ' ...
    'long zero padding in the correlation function caculation seems \n' ...
    'to suitable to avoid mirrowing effects in the correlation function. \n\n']) ...
    ,logFilePath,false);

%% Preallocation
if ~exist('nearestNeighbourCases','var')
    logMessage('Preallocation of arrays as a first part of the script' ...
        ,logFilePath,true);
    nearestNeighbourCases = getNearestNeighbourCases(configuration ...
        ,numberOfHs,logFilePath);
    nearestNeighbourCasesCount = size(nearestNeighbourCases,2);
    nearestNeighbours = max(nearestNeighbourCases);
    
    [fibreAnglesTheta,fibreAnglesThetaCount,fibreAnglesPhi ...
        ,fibreAnglesPhiCount] = getThetaAndPhiFromConfiguration( ...
        configuration,logFilePath);
    
    averagingRegionForSpecDens = getAveragingRegionForSpecDens( ...
        configuration.averagingRegionForSpectralDensity,logFilePath);
    
    atomCounter = configuration.atomCounter;
    calculatedAtomIndices = zeros(1,atomsToCalculate);
    calculationSteps = fibreAnglesThetaCount*fibreAnglesPhiCount;
    
    randomSequenceOfAtoms = randperm(numberOfHs);
    logMessage(sprintf('%s:%s', 'Random sequence of atoms: ' ...
        ,sprintf(' %i',randomSequenceOfAtoms(1:15))),logFilePath,false);
    
    nearestNeighboursIDs = zeros(1,max(nearestNeighbourCases));
    nearestNeighbourDistancesPow3 = zeros(max(nearestNeighbourCases) ...
        ,timeSteps,'single');
    
    rotatedX = zeros(max(nearestNeighbourCases),timeSteps,'single');
    rotatedY = zeros(max(nearestNeighbourCases),timeSteps,'single');
    rotatedZ = zeros(max(nearestNeighbourCases),timeSteps,'single');
    
    polarAngle = zeros(max(nearestNeighbourCases),timeSteps,'single');
    azimuthAngle = zeros(max(nearestNeighbourCases),timeSteps,'single');
    
    sphericalHarmonicZerothOrder = zeros(max(nearestNeighbourCases) ...
        ,timeSteps,'like',double(1j));
    sphericalHarmonicFirstOrder = zeros(max(nearestNeighbourCases) ...
        ,timeSteps,'like',double(1j));
    sphericalHarmonicSecondOrder = zeros(max(nearestNeighbourCases) ...
        ,timeSteps,'like',double(1j));
    
    for nearestNeighboursCase = nearestNeighbourCases
        key = sprintf('nearestNeighbours%g',nearestNeighboursCase);
        
        r1Estimation_NN.(key) = zeros(1);
        
        correlationFunctionZerothOrder.(key) = zeros(1,timeSteps ...
            ,'like',double(1j));
        correlationFunctionFirstOrder.(key) = zeros(1,timeSteps ...
            ,'like',double(1j));
        correlationFunctionSecondOrder.(key) = zeros(1,timeSteps ...
            ,'like',double(1j));
        
        sumCorrFuncZerothOrder.(key) = zeros( ...
            fibreAnglesThetaCount,fibreAnglesPhiCount,timeSteps,'like' ...
            ,double(1j));
        sumCorrFuncFirstOrder.(key) = zeros( ...
            fibreAnglesThetaCount,fibreAnglesPhiCount,timeSteps,'like' ...
            ,double(1j));
        sumCorrFuncSecondOrder.(key) = zeros( ...
            fibreAnglesThetaCount,fibreAnglesPhiCount,timeSteps,'like' ...
            ,double(1j));
    end
    logMessage('Arrays successfully preallocated',logFilePath,false);
    return;
end
meanPositions = single([mean(trajectoryX,2) mean(trajectoryY,2) ...
        mean(trajectoryZ,2)]);
atomTimer = zeros(1,atomsToCalculate);
%% Start simulation
printBreakLineToLogFile(logFilePath);
logMessage('Rotate whole dataset',logFilePath,true);
phi = fibreAnglesPhi(1);
zAxis = [0 0 1];
rotationMatrixPhi = get3DRotationMatrix(phi,zAxis);
theta = fibreAnglesTheta(1);
yAxis = [0 1 0];
rotationMatrixTheta = get3DRotationMatrix(theta,yAxis);
totalRotationMatrix = ...
    rotationMatrixTheta*rotationMatrixPhi;
[trajectoryX,trajectoryY,trajectoryZ]  ...
    = rotateTrajectoriesWithRotationMatrix( ...
    totalRotationMatrix,trajectoryX,trajectoryY,trajectoryZ);
% trajectories is now rotated and used because only one angle is used and
% therefore this step is performed before the the loop.

logMessage('Start simulation.',logFilePath,true);
for atomNumber = randomSequenceOfAtoms(atomCounter:atomsToCalculate)
    atomTimerStart = tic;
    logMessage(sprintf('Selected atom number %i',atomNumber),logFilePath ...
        ,false);
    calculatedAtomIndices(atomCounter) = atomNumber; %#ok<SAGROW>
    
    [trajectoryX,trajectoryY,trajectoryZ] = calculateRelativePositions( ...
        trajectoryX,trajectoryY,trajectoryZ,atomNumber);
    
    [nearestNeighboursIDs,nearestNeighbourDistancesPow3] =  ...
        findNearestNeighboursIDs(nearestNeighbours,trajectoryX ...
        ,trajectoryY,trajectoryZ);
    
    [polarAngle,azimuthAngle] = ...
        transformToSphericalCoordinates(trajectoryX( ...
        nearestNeighboursIDs,:),trajectoryY(nearestNeighboursIDs,:) ...
        ,trajectoryZ(nearestNeighboursIDs,:));
                
    [sphericalHarmonicZerothOrder,sphericalHarmonicFirstOrder ...
        ,sphericalHarmonicSecondOrder] = calculateSphericalHarmonics( ...
        polarAngle,azimuthAngle,nearestNeighbourDistancesPow3);
    
    correlationFunctionZerothOrder = ...
        calculateCorrelationFunctionForDifferentNNCases( ...
        sphericalHarmonicZerothOrder,nearestNeighbourCases);
    sumCorrFuncZerothOrder = addTwoCorrelationFunctionStructs( ...
        sumCorrFuncZerothOrder,correlationFunctionZerothOrder,1,1);
    correlationFunctionFirstOrder = ...
        calculateCorrelationFunctionForDifferentNNCases( ...
        sphericalHarmonicFirstOrder,nearestNeighbourCases);
    sumCorrFuncFirstOrder = addTwoCorrelationFunctionStructs( ...
        sumCorrFuncFirstOrder,correlationFunctionFirstOrder,1,1);
    correlationFunctionSecondOrder = ...
        calculateCorrelationFunctionForDifferentNNCases( ...
        sphericalHarmonicSecondOrder,nearestNeighbourCases);
    sumCorrFuncSecondOrder = addTwoCorrelationFunctionStructs( ...
        sumCorrFuncSecondOrder,correlationFunctionSecondOrder,1,1);
    
    for fieldName = string(fieldnames(sumCorrFuncFirstOrder))'
        [averageSpectralDensityFirstOrder ...
            ,averageSpectralDensitySecondOrder] ...
            = calculateSpectralDensities( ...
            sumCorrFuncFirstOrder.(fieldName)/atomCounter ...
            ,sumCorrFuncSecondOrder.(fieldName)/atomCounter,omega0 ...
            ,deltaTInS,averagingRegionForSpecDens);
        
        r1Estimation_NN.(fieldName) = calculateR1WithSpectralDensity( ...
            averageSpectralDensityFirstOrder ...
            ,averageSpectralDensitySecondOrder,dipolDipolConstant);
        
        logMessage(sprintf(['=> %s\n' ...
            '    Estimated relaxation rate for calculated atoms:' ...
            ' %.4f\n'],fieldName,r1Estimation_NN.(fieldName)) ...
            ,logFilePath,false);
    end
    
    printDottedBreakLineToLogFile(logFilePath);
    if mod(atomCounter,configuration.savingIntervall) == 0
        lastSavingDate = datestr(now,'yyyymmdd_HHMM');
        createDataSavingObject();
        save(resultsFileSavingPath,'-struct','dataSavingObject','-v7.3');
        logMessage('Saved data',logFilePath);
    end
    logMessage(sprintf('Calculated %i atom(s)',atomCounter),logFilePath ...
        ,false);
    atomTimer(atomCounter) = toc(atomTimerStart);
    averageTimeForOneAtom = seconds(mean(atomTimer(1:atomCounter)));
    logMessage(sprintf([' ---> Average time for one atom: %s \n' ...
        '        Average time for one phi/theta: %s \n'...
        '        Approximately ready on: %s.'] ...
        ,datestr(averageTimeForOneAtom,'HH:MM:SS') ...
        ,datestr(averageTimeForOneAtom/calculationSteps,'HH:MM:SS') ...
        ,datetime('now')+averageTimeForOneAtom ...
        *(atomsToCalculate-atomCounter)),logFilePath,false);
    printEqualSignBreakLineToLogFile(logFilePath);
    atomCounter = atomCounter + 1;
end

